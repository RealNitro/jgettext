/*
 * JBoss, the OpenSource J2EE webOS
 * 
 * Distributable under LGPL license.
 * See terms of license at gnu.org.
 */
package org.fedorahosted.tennera.antgettext;

import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.util.Date;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.GlobPatternMapper;
import org.fedorahosted.openprops.Properties;
import org.fedorahosted.tennera.jgettext.Catalog;
import org.fedorahosted.tennera.jgettext.Message;
import org.fedorahosted.tennera.jgettext.Occurence;
import org.fedorahosted.tennera.jgettext.catalog.write.CatalogWriter;

/**
 * Converts Java Properties files into gettext template files (POT).
 * 
 * @author <a href="sflaniga@redhat.com">Sean Flanigan</a>
 * @version $Revision: $
 */
public class Prop2PotTask extends MatchingTask
{
   private File srcDir;
   private File dstDir;
   private FileNameMapper mapper;
   private boolean includeAll;

   // This should be pretty safe, at least for ISO-8859-1 files
   private static final String NEWLINE_REGEX = "(\r\n|\r|\n)"; //$NON-NLS-1$

   public void setSrcDir(File srcDir)
   {
      this.srcDir = srcDir;
   }

   public void setDstDir(File dstDir)
   {
      this.dstDir = dstDir;
   }
   
   public void setIncludeAll(boolean includeAll) 
   {
      this.includeAll = includeAll;
   }
   
   public void add(FileNameMapper mapper)
   {
	   if (this.mapper != null)
		   throw new BuildException("mapper already set!");
	   this.mapper = mapper;
   }
   
   @Override
   public void execute() throws BuildException
   {
      DirUtil.checkDir(srcDir, "srcDir", false); //$NON-NLS-1$
      DirUtil.checkDir(dstDir, "dstDir", true); //$NON-NLS-1$

      if (mapper == null)
      {
    	  // use default filename mapping if unset:
    	  GlobPatternMapper globMap = new GlobPatternMapper();
    	  globMap.setFrom("*.properties"); //$NON-NLS-1$
    	  globMap.setTo("*.pot"); //$NON-NLS-1$
    	  mapper = globMap;
      }
      try
      {
         DirectoryScanner ds = super.getDirectoryScanner(srcDir);
         // use default includes if unset:
         if(!getImplicitFileSet().hasPatterns())
             ds.setIncludes(new String[] {"**/*.properties"}); //$NON-NLS-1$
         ds.scan();
         String[] files = ds.getIncludedFiles();

         for (int i = 0; i < files.length; i++)
         {
            String propFilename = files[i];
            File propFile = new File(srcDir, propFilename);
            String[] outFile = mapper.mapFileName(propFilename);
            if (outFile == null || outFile.length == 0)
            {
            	log("Skipping "+propFilename+": filename mapped to null", Project.MSG_VERBOSE);
            	continue;
            }
            String potFilename = outFile[0]; // FIXME support multiple output mappings
            File potFile = new File(dstDir, potFilename);
            if(potFile.lastModified() > propFile.lastModified())
            {
            	log("Skipping " + propFilename + ": " + potFile.getPath()
							+ " is up to date", Project.MSG_VERBOSE);
            	continue;
            }
            Properties props = new Properties();
            BufferedInputStream in = new BufferedInputStream(new FileInputStream(propFile));
            props.load(in);
            log("Generating "+potFile+" from "+propFile, Project.MSG_VERBOSE);
            potFile.getParentFile().mkdirs();
            BufferedWriter out = new BufferedWriter(new FileWriter(potFile));
            try
            {
//               String genComment = potFilename+" generated by "+Prop2PotTask.class.getName()+" from "+propFilename;
//               PotWritingUtil.writePotHeader(out);
        	Catalog cat = new Catalog(true);
        	CatalogWriter writer = new CatalogWriter(cat);

        	// this will be >0 if we are inside a NON-TRANSLATABLE block
        	int nonTranslatable = 0;
        	for (String key : props.stringPropertyNames())
        	{
        	   String englishString = props.getProperty(key);
        	   // NB java.util.Properties throws away comments...

               String comment;
               if (includeAll) 
               {
                  comment = props.getComment(key);
               } 
               else 
               {
               	  String raw = props.getRawComment(key);

               	  if (raw != null) 
                  {
                     StringBuilder sb = new StringBuilder(raw.length());
                     String[] lines = raw.split(NEWLINE_REGEX);
                     for (int j = 0; j < lines.length; j++) 
                     {
                        String line = lines[j];
                        // See http://wiki.eclipse.org/Eclipse_Globalization_Guidelines#Non-translatable_Message_Strings
                        if (line.equals("# START NON-TRANSLATABLE")) //$NON-NLS-1$ 
                        {
                           ++nonTranslatable;
                        } 
                        else if (line.equals("# END NON-TRANSLATABLE")) //$NON-NLS-1$
                        {
                           --nonTranslatable;
                           if (nonTranslatable < 0)
                              throw new BuildException(
                                    "Found '# END NON-TRANSLATABLE' " +
                                    "without matching " +
                                    "'# START NON-TRANSLATABLE': file="+propFile+" key="+key);
                        } 
                        else if (nonTranslatable == 0) 
                        {
                           sb.append(Properties.cookCommentLine(line));
                           if (j+1 < lines.length)
                              sb.append('\n');
                        }
                     }
                     comment = sb.toString();
                  } 
                  else 
                  {
                     comment = null;
                  }
               }
               if (nonTranslatable == 0) 
               {
                  Message message = new Message();
                  message.addExtractedComment(comment);
                  message.addOccurence(new Occurence(key));
                  message.addFormat("java-format"); //  FIXME check this //$NON-NLS-1$
                  message.setMsgctxt(key);
                  message.setMsgid(englishString);
                  cat.addMessage(message);
               }
            }
        	// TODO check that footerComment balances out nonTranslatable count 
        	writer.writeTo(out, new Date(propFile.lastModified()));
            }
            finally
            {
               in.close();
               out.close();
            }
         }
      }
      catch (Exception e)
      {
         throw new BuildException(e);
      }
   }

}
